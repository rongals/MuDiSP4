//
// MuDiSP3 (Multirate Digital Signal Processor 3)
// Copyright 1999, Luca Simone Ronga
//
//
//  This file is part of MuDiSP3.
//
//  MuDiSP3 is free software; you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation; either version 2 of the License, or
//  (at your option) any later version.
//
//  MuDiSP3 is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with MuDiSP3; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
/////////////////////////////////////////////////////////


#include <iostream>
#include <fstream>
#include <string>
#include <stdio.h> 
#include <stdlib.h>

using namespace std;

int main(int argc, char* argv[]) {

  
  if (argc < 3) {
    cerr << "Usage: "
	 << endl << argv[0] << " <base param file> "
	 << " <options file> [<options file> ...]"
	 << endl << endl;

    cerr << "This tool  is  useful   to  merge  parameters  lines from" << endl
	 << "different files. It takes out a  line  from  each  option" << endl
	 << "file and merge them with all the  lines in the base param" << endl
	 << "file. Each option file must have the same number of valid" << endl
	 << "lines, otherwise an error will be issued." << endl
	 << " " << endl;

    exit(0);
  }

//
// open the option files...
//

  ifstream opt_ifs[argc-2];
  
  for (int i=0; i<(argc-2); i++) {
    opt_ifs[i].open(argv[i+2]);  
    if (! opt_ifs[i] ) {
      cerr << "Error opening " << argv[i+2] << ". Aborting." << endl;
      exit(1);
    }
  }
 
//
// the are opts files opened. Then read a line from the first opt file...
//

  unsigned int filecount = 0;
  string str[argc-2],bstr;
  size_t ptr[argc-2];
  
  while( getline(opt_ifs[0],str[0]) ) {
    
    //
    // I look for a valid line in the first opt file
    //
    if (((ptr[0]=str[0].find(":")) != str[0].npos) && (str[0][0] != ';')) {
      
      //
      // then I need a valid line for each remaining opt file. 
      // 
      for (int i=1; i<(argc-2); i++) {
	while( getline(opt_ifs[i],str[i]) )
	  if (((ptr[i]=str[i].find(":")) != str[i].npos) && (str[i][0] != ';'))
	    break;
	if (opt_ifs[i].eof()) {
	  cerr << "Error: reached unexpected EOF in " << argv[i+2] 
	       << endl;
	  exit(1);
	}
      }
      
      //
      // Build the Output file name and open it from the base filename
      //
      char tmp[128];
      string ofn(argv[1]), stmp;
      size_t dotpos;
      
      dotpos = ofn.find_last_of('.');
      sprintf(tmp,"%03d",filecount++);
      stmp = string("_") + string(tmp);
      ofn.insert(dotpos,stmp);
      
      cout << "Producing : " << ofn.c_str() << endl;
      
      ofstream ofs(ofn.c_str());

      //
      // now open the base file
      // 

      ifstream base_ifs(argv[1]);       
      
      if (! base_ifs ) {
	cerr << "Error opening " << argv[1] << ". Aborting." << endl;
	exit(1);
      }

      //
      // first the params from the opt files
      //
      ofs << ";\n; Generated by param_exploder\n;\n";
      for (int i=0; i<(argc-2); i++) 
	ofs << str[i].c_str() << endl;
      

      //
      // then a copy of the base_file
      //
      while( getline(base_ifs,bstr) ) {
	ofs << bstr.c_str() << endl;
      }

      //
      // close the base and output files
      //
      ofs.close();
      base_ifs.close();

    }
  }
  
// close all the files

  for (int i=0; i<(argc-2); i++) 
    opt_ifs[i].close();  
  
// exit in peace ...

}

